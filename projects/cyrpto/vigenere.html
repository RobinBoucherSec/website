<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Vigenère Cipher | Robin Boucher</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" />
    <style>
        body {
            background: url('../../images/pic02.jpg') center center/cover no-repeat fixed;
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
        }
        .centered-layout {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
        }
        .main-content {
            background: rgba(40,0,60,0.92);
            color: #fff !important;
            margin: 2em 0;
            padding: 2em 2.5em;
            border-radius: 18px;
            box-shadow: 0 0 24px rgba(60,0,80,0.12);
            min-width: 320px;
            max-width: 800px;
            font-size: 0.97em;
        }
        .main-content h1, .main-content h2, .main-content h3, .main-content strong, .main-content em, .main-content code, .main-content a {
            color: #fff !important;
        }
        .main-content a {
            font-weight: bold;
        }
        .main-content a.button-link, .btn {
            display: inline-block;
            margin-top: 1.2em;
            margin-bottom: 1.2em;
            background: #741761;
            color: #fff !important;
            font-weight: bold;
            text-decoration: none;
            font-size: 1.1em;
            padding: 0.7em 1.6em;
            border-radius: 1.2em;
            box-shadow: 0 2px 8px rgba(60,0,80,0.10);
            transition: background 0.2s;
        }
        .main-content a.button-link:hover, .btn:hover {
            background: #3a0066;
            color: #fff !important;
        }
        .project-block {
            border-radius: 12px;
            box-shadow: 0 2px 12px rgba(60,0,80,0.07);
            padding: 1.2em 1.5em;
            margin-bottom: 2em;
            background: rgba(80,0,100,0.25);
        }
        .code-container {
            background: #111 !important; /* Black background */
            border-radius: 12px;
            padding: 1em;
            margin-top: 1em;
            color: #fff !important;
            overflow-x: auto;
        }
        .explanation-block {
            background: rgba(80,0,100,0.18);
            border-radius: 12px;
            padding: 1.2em 1.5em;
            margin-bottom: 2em;
            color: #fff;
        }
        @media (max-width: 900px) {
            .centered-layout {
                flex-direction: column;
            }
            .main-content {
                margin: 0;
                border-radius: 0;
                min-width: unset;
                max-width: unset;
                padding: 1em 0.5em;
            }
        }
    </style>
</head>
<body>
    <div class="centered-layout">
        <div class="main-content">
            <h1 style="text-align: center;">Vigenère Cipher Project</h1>
            <p style="text-align: center;">Robin Boucher - Cryptography Portfolio</p>

            <!-- Section 1: Fonctions de Base du Chiffrement -->
            <div class="project-block">
                <h2>1. Fonctions de Base du Chiffrement</h2>
                <p><strong>Le Codeur et Décodeur</strong></p>
                <p>
                    <strong>vigenere_encrypt</strong> : Transforme un message normal en code secret avec un mot-clé (ex : "BONJOUR" + "CLE" → "DSPLYXZ").<br>
                    <strong>vigenere_decrypt</strong> : Retrouve le message original si on a le bon mot-clé.
                </p>
                <p>
                    <em>Analogie :</em> Imaginez un cadran alphabétique qui tourne différemment pour chaque lettre en fonction du mot-clé – c'est comme ça que le message est brouillé !
                </p>
                <div class="code-container">
<pre><code>def vigenere_chiffrer(texte_clair: str, cle: str, conserver_casse: bool = True) -> str:
    texte_chiffre = []
    cle_repetee = (cle * (len(texte_clair) // len(cle) + 1)).lower()
    index_cle = 0
    for caractere in texte_clair:
        if caractere.isalpha():
            base = ord('A') if caractere.isupper() else ord('a')
            caractere_cle = cle_repetee[index_cle]
            decalage = ord(caractere_cle) - ord('a')
            caractere_chiffre = chr((ord(caractere.lower()) - ord('a') + decalage) % 26 + base)
            texte_chiffre.append(caractere_chiffre if conserver_casse else caractere_chiffre.upper())
            index_cle += 1
        else:
            texte_chiffre.append(caractere)
    return ''.join(texte_chiffre)

def vigenere_dechiffrer(texte_chiffre: str, cle: str, conserver_casse: bool = True) -> str:
    texte_clair = []
    cle_repetee = (cle * (len(texte_chiffre) // len(cle) + 1)).lower()
    index_cle = 0
    for caractere in texte_chiffre:
        if caractere.isalpha():
            base = ord('A') if caractere.isupper() else ord('a')
            caractere_cle = cle_repetee[index_cle]
            decalage = ord(caractere_cle) - ord('a')
            caractere_dechiffre = chr((ord(caractere.lower()) - ord('a') - decalage) % 26 + base)
            texte_clair.append(caractere_dechiffre if conserver_casse else caractere_dechiffre.upper())
            index_cle += 1
        else:
            texte_clair.append(caractere)
    return ''.join(texte_clair)
</code></pre>
                </div>
            </div>

            <!-- Section 2: Outils de Cryptanalyse -->
            <div class="project-block">
                <h2>2. Outils de Cryptanalyse</h2>
                <p><strong>Le Kit du Détective de Codes</strong></p>
                <p>
                    <strong>Indice de Coïncidence</strong> : Mesure à quel point le code semble aléatoire (pour deviner le type de chiffrement).<br>
                    <strong>Examen de Kasiski</strong> : Repère des motifs répétés pour estimer la longueur du mot-clé (ex : "ABC" apparaît tous les 5 caractères).<br>
                    <strong>Attaque par Fréquence</strong> : Utilise la fréquence des lettres (ex : "E" est la plus courante en français) pour deviner le mot-clé.
                </p>
                <p>
                    <em>Utilité :</em> Ce sont les mêmes techniques que les vrais cryptanalystes utilisent pour casser des codes sans connaître la clé !
                </p>
                <div class="code-container">
<pre><code>def calculer_indice_coincidence(texte: str) -> float:
    texte = re.sub(r'[^a-zA-Z]', '', texte).lower()
    if len(texte) < 2:
        return 0.0
    freq = Counter(texte)
    total = len(texte)
    ic = sum(count * (count - 1) for count in freq.values()) / (total * (total - 1))
    return ic

def examen_kasiski(texte_chiffre: str, longueur_cle_max: int = 10) -> list:
    texte_chiffre = re.sub(r'[^a-zA-Z]', '', texte_chiffre).upper()
    sequences = {}
    for longueur in range(3, 6):
        for i in range(len(texte_chiffre) - longueur):
            seq = texte_chiffre[i:i + longueur]
            if seq in sequences:
                sequences[seq].append(i)
            else:
                sequences[seq] = [i]
    distances = []
    for seq, positions in sequences.items():
        if len(positions) > 1:
            for i in range(len(positions)):
                for j in range(i + 1, len(positions)):
                    distances.append(positions[j] - positions[i])
    facteurs = Counter()
    for distance in distances:
        for longueur_possible in range(2, min(distance, longueur_cle_max) + 1):
            if distance % longueur_possible == 0:
                facteurs[longueur_possible] += 1
    return [longueur for longueur, _ in facteurs.most_common()]

def attaque_frequence(texte_chiffre: str, longueur_cle_probable: int = None, langue: str = 'fr') -> str:
    tables_freq = {
        'en': 'etaoinshrdlcumwfgypbvkjxqz',
        'fr': 'easnrtoulidcmpévqfbghjàxèyêzwk'
    }
    texte_chiffre_propre = re.sub(r'[^a-zA-Z]', '', texte_chiffre).upper()
    if longueur_cle_probable is None:
        longueur_cle_probable = examen_kasiski(texte_chiffre)[0] if len(texte_chiffre) > 50 else 1
    groupes = [''] * longueur_cle_probable
    for i, caractere in enumerate(texte_chiffre_propre):
        groupes[i % longueur_cle_probable] += caractere
    cle_devinee = []
    for groupe in groupes:
        freq = Counter(groupe.lower())
        plus_frequent = freq.most_common(1)[0][0]
        decalage_devine = (ord(plus_frequent) - ord(tables_freq[langue][0])) % 26
        cle_devinee.append(chr(decalage_devine + ord('a')))
    cle_devinee = ''.join(cle_devinee)
    return vigenere_dechiffrer(texte_chiffre, cle_devinee)
</code></pre>
                </div>
            </div>

            <!-- Section 3: Améliorations de Sécurité -->
            <div class="project-block">
                <h2>3. Améliorations de Sécurité</h2>
                <p><strong>Comment Rendre le Code Plus Dur à Casser</strong></p>
                <p>
                    <strong>Niveau 1</strong> : Chiffrement de base.<br>
                    <strong>Niveau 2</strong> : Ajoute des symboles aléatoires et inverse le message (pour tromper les attaques simples).<br>
                    <strong>Niveau 3</strong> : Chiffre deux fois avec une clé modifiée (comme un double verrou).
                </p>
                <p>
                    <em>Comparaison réelle :</em> C'est comme passer d’un cadenas simple (Niveau 1) à un coffre-fort (Niveau 3) pour vos messages.
                </p>
                <div class="code-container">
<pre><code>def vigenere_ameliorer_chiffrement(texte_clair: str, cle: str, niveau_securite: int = 1) -> str:
    if niveau_securite == 1:
        return vigenere_chiffrer(texte_clair, cle)
    elif niveau_securite == 2:
        texte_inverse = texte_clair[::-1]
        texte_chiffre = vigenere_chiffrer(texte_inverse, cle)
        import random
        resultat = []
        caracteres_bruit = '!@#$%^&*()_+-=[]{}|;:,.<>?'
        i = 0
        while i < len(texte_chiffre):
            taille_bloc = random.randint(3, 5)
            bloc = texte_chiffre[i:i + taille_bloc]
            resultat.append(bloc)
            if i + taille_bloc < len(texte_chiffre):
                resultat.append(random.choice(caracteres_bruit))
            i += taille_bloc
        return ''.join(resultat)
    elif niveau_securite == 3:
        premier_passage = vigenere_chiffrer(texte_clair, cle)
        cle_transformee = ''.join(
            chr((ord(c.lower()) - ord('a') + 1) % 26 + ord('a'))
            for c in cle[::-1]
        )
        return vigenere_chiffrer(premier_passage, cle_transformee)
</code></pre>
                </div>
            </div>

            <!-- Section 4: Mode Interactif -->
            <div class="project-block">
                <h2>4. Mode Interactif</h2>
                <p><strong>Un Bac à Sable pour Jouer avec les Codes</strong></p>
                <p>
                    Permet de :<br>
                    - Chiffrer/Déchiffrer des messages en temps réel.<br>
                    - Tester les outils de cryptanalyse.<br>
                    - Comparer les niveaux de sécurité.
                </p>
                <p>
                    <em>Idéal pour :</em> Expérimenter comme un espion, sans avoir besoin de programmer !
                </p>
                <div class="code-container">
<pre><code>def mode_interactif():
    print("Outil de chiffrement de Vigenère - Mode interactif")
    print("Commandes : chiffrer, dechiffrer, analyser, ameliorer, quitter")
    while True:
        commande = input("\n> ").strip().lower()
        if commande in ('quitter', 'exit'):
            break
        elif commande == 'chiffrer':
            texte = input("Entrez le texte à chiffrer : ")
            cle = input("Entrez la clé de chiffrement : ")
            print("Texte chiffré :", vigenere_chiffrer(texte, cle))
        elif commande == 'dechiffrer':
            texte = input("Entrez le texte à déchiffrer : ")
            cle = input("Entrez la clé de déchiffrement : ")
            print("Texte déchiffré :", vigenere_dechiffrer(texte, cle))
        elif commande == 'analyser':
            texte = input("Entrez le texte chiffré à analyser : ")
            print("\nIndice de coïncidence :", calculer_indice_coincidence(texte))
            print("\nRésultats de l'examen de Kasiski :")
            longueurs_cles = examen_kasiski(texte)
            if longueurs_cles:
                print("Longueurs de clé probables :", ', '.join(map(str, longueurs_cles)))
                print("\nTentative d'attaque par fréquence...")
                texte_dechiffre = attaque_frequence(texte, longueurs_cles[0])
                print("\nMeilleure estimation du texte déchiffré :")
                print(texte_dechiffre)
            else:
                print("Pas assez de données pour l'examen de Kasiski")
        elif commande == 'ameliorer':
            texte = input("Entrez le texte à chiffrer avec améliorations : ")
            cle = input("Entrez la clé de chiffrement : ")
            niveau = input("Niveau de sécurité (1-3) : ")
            try:
                niveau = int(niveau)
                if 1 <= niveau <= 3:
                    print("Texte chiffré amélioré :",
                          vigenere_ameliorer_chiffrement(texte, cle, niveau))
                else:
                    print("Veuillez entrer un niveau entre 1 et 3")
            except ValueError:
                print("Niveau de sécurité invalide")
        else:
            print("Commande inconnue. Essayer : chiffrer, dechiffrer, analyser, ameliorer, quitter")
</code></pre>
                </div>
            </div>

            <!-- Section 5: Démonstration -->
            <div class="project-block">
                <h2>5. Démonstration</h2>
                <p><strong>Un Aperçu Rapide</strong></p>
                <p>
                    Montre automatiquement :<br>
                    - Un exemple de message chiffré.<br>
                    - Les outils de cassage de code en action.<br>
                    - Comment les niveaux de sécurité changent le résultat.
                </p>
                <p>
                    <em>Pour les débutants :</em> Lancez cette fonction pour voir tout ce que le toolkit peut faire en quelques secondes !
                </p>
                <div class="code-container">
<pre><code>def demontrer():
    print("=" * 60)
    print("DÉMONSTRATION DE L'OUTIL DE CHIFFREMENT DE VIGENÈRE".center(60))
    print("=" * 60)
    texte_clair = "Le chiffre de Vigenère est une méthode de chiffrement qui utilise une série de différentes transformations par substitution."
    cle = "clef"
    print("\n1. CHIFFREMENT/DÉCHIFFREMENT DE BASE")
    print("-" * 60)
    texte_chiffre = vigenere_chiffrer(texte_clair, cle)
    print(f"Original : {texte_clair[:50]}...")
    print(f"Chiffré : {texte_chiffre[:50]}...")
    texte_dechiffre = vigenere_dechiffrer(texte_chiffre, cle)
    print(f"Déchiffré : {texte_dechiffre[:50]}...")
    print("\n2. OUTILS DE CRYPTANALYSE")
    print("-" * 60)
    print(f"Indice de coïncidence : {calculer_indice_coincidence(texte_chiffre):.4f}")
    print("Examen de Kasiski (longueurs de clé probables) :",
          examen_kasiski(texte_chiffre))
    print("\n3. AMÉLIORATIONS DE SÉCURITÉ")
    print("-" * 60)
    print("Niveau 1 (basique) :", vigenere_chiffrer("Message secret", "cle")[:30] + "...")
    print("Niveau 2 (bruit) :", vigenere_ameliorer_chiffrement("Message secret", "cle", 2)[:30] + "...")
    print("Niveau 3 (double) :", vigenere_ameliorer_chiffrement("Message secret", "cle", 3)[:30] + "...")
    print("\n" + "=" * 60)
    print("Essayez le mode interactif pour plus de fonctionnalités !".center(60))
    print("=" * 60)

if __name__ == '__main__':
    demontrer()
    # Décommenter pour lancer le mode interactif par défaut :
    # mode_interactif()
</code></pre>
                </div>
            </div>

            <div style="text-align: center; margin-top: 30px;">
                <a href="main_page_crypto.html" class="button-link">&larr; Retour à l'accueil crypto</a>
            </div>
        </div>
    </div>
</body>
</html>